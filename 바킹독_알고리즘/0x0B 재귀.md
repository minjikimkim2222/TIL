연습문제 3가지와 함께, 절차 지향적 사고를 탈피하고 **귀납적 사고**를 가지는 연습을 하자!

0.귀납적 사고(vs 절차지향적 사고),  with 예제
====
  1. 틀
       - 도미노 1번이 쓰러진다 [**자명한 사실**]
       - k번이 쓰러진다 -> (k+1)도 쓰러진다 [**재귀문**]
  2. 예제
       - 자명한 사실 : fun1(1)이 1을 출력한다.
       - 보여야할 사실 : fun1(k)가 k,k-1,..1을 출력하면, fun1(k+1)이 k+1, k, k-1 , ..1을 출력한다.</br>
           - 즉, fun1(k+1)이 호출된 뒤, 다음과 같이 코드를 짜면 됨. </br>
               1] k+1이 출력된다.</br>
               2] fun1(k) 함수가 호출된다. </br>
              -> 따라서 "귀납적으로" fun1(k) 함수가 k, k-1, ... 1까리 차례로 출력하는 함수임을 알 수 있다!
  3. 참고, 재귀 base condition
       - base condition은 필수, 잘못 짜면 무한재귀
</br>
             
1.재귀 정보1 : 함수 틀 정확히 잡기
====
  - 함수 인자를 무엇으로 받을지, 어디까지 계산한 후 자기 자신에게 넘겨줄 지 잡는 연습하기
  - 언제 재귀? 언제 반복문?
      - 메모리, 시간적 타임오바에 취약한 재귀
      - 반면, 코드가 복잡한 반복문
</br>

2.재귀정보 2 : 한 함수가 자기 자신을 호출하면[재귀] 비효율적일 수 있다.
===
  - 재귀로, 한 함수가 자기 자신을 여러 번 호출하게 되면, **중복 계산**이 발생해, 시간복잡도가 말도 안 되게 커질 수 있다.
  - 강의안에 피보나치 수열로 예제를 듦.
  - 이 문제는 후에 배울 **Dynamic Programming**을 통해 O(n)으로 해결 가능하다! [중복 계산 탈피]

</br>

3.재귀정보 3 : 재귀함수는 호출될 때마다, 스택 영역에 누적됨
====
  - 스택 메모리가 작게 제한된 곳에서 문제를 풀 때는 재귀 대신 반복문 추천
  - 런타임 에러 발생 시 의심
      - 재귀가 너무 깊거나
      - 지역변수로 int arr[2000][2000] 같이 너무 큰 배열을 잡지는 않았는디
          - int 400개면 벌써 16MB를 잡아먹기에
</br>

### 연습문제를 풀며, 재귀의 꽃인 "귀납적 사고"를 알아봄
### 해당 예제 정리는 algorithm 0x0B에 있다.
